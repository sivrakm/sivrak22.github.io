import{c as _,e as n,d as o,au as l,h as d,f as b,b as i,n as g,g as y,av as h,aw as m,ax as p,ay as f,az as C,aA as A,aB as E,aC as P,aD as v,aE as I,aF as T,aG as D,aH as S,aI as R,aJ as F,aK as Q,aL as L,aM as x,aN as V,aO as w,aP as B,aQ as q,aR as M,aS as k,aT as N,aU as O,aV as W,aW as U,aX as G,aY as H,aZ as z,a_ as J,a$ as K,b0 as j,b1 as Z,b2 as $,b3 as X,b4 as Y,b5 as ee,b6 as ae,b7 as re,b8 as se,b9 as te,ba as oe,bb as ne,bc as ie,bd as ce,be as le,bf as ue,bg as de,bh as be,bi as ge,bj as ye,bk as _e,bl as he,bm as me,bn as pe,bo as fe,bp as Ce,bq as Ae,br as Ee,bs as Pe,bt as ve,bu as Ie,bv as Te,bw as De,bx as Se,by as Re,bz as Fe,bA as Qe,bB as Le,bC as xe,bD as Ve,bE as we,bF as Be,bG as qe,bH as Me,bI as ke,bJ as Ne,bK as Oe,bL as We,bM as Ue,bN as Ge,bO as He,bP as ze,bQ as Je,bR as Ke,bS as je,bT as Ze,bU as $e,bV as Xe,o as Ye,bW as ea,bX as aa,bY as ra,q as sa,bZ as ta,b_ as oa,b$ as na,c0 as ia,a0 as ca,c1 as la,c2 as ua,c3 as da,c4 as ba,c5 as ga,c6 as ya,c7 as _a,c8 as ha,c9 as ma,ca as pa,w as fa,cb as Ca}from"./index-CA5h76Mg.js";const u=Object.freeze(Object.defineProperty({__proto__:null,AbstractUserDataWriter:h,AggregateField:m,AggregateQuerySnapshot:p,Bytes:f,CACHE_SIZE_UNLIMITED:C,CollectionReference:A,DocumentReference:E,DocumentSnapshot:P,FieldPath:v,FieldValue:I,Firestore:T,FirestoreError:D,GeoPoint:S,LoadBundleTask:R,PersistentCacheIndexManager:F,Query:Q,QueryCompositeFilterConstraint:L,QueryConstraint:x,QueryDocumentSnapshot:V,QueryEndAtConstraint:w,QueryFieldFilterConstraint:B,QueryLimitConstraint:q,QueryOrderByConstraint:M,QuerySnapshot:k,QueryStartAtConstraint:N,SnapshotMetadata:O,Timestamp:W,Transaction:U,VectorValue:G,WriteBatch:H,_AutoId:z,_ByteString:J,_DatabaseId:K,_DocumentKey:j,_EmptyAppCheckTokenProvider:Z,_EmptyAuthCredentialsProvider:$,_FieldPath:X,_TestingHooks:Y,_cast:ee,_debugAssert:ae,_internalAggregationQueryToProtoRunAggregationQueryRequest:re,_internalQueryToProtoQueryTarget:se,_isBase64Available:te,_logWarn:oe,_validateIsNotUsedTogether:ne,addDoc:g,aggregateFieldEqual:ie,aggregateQuerySnapshotEqual:ce,and:le,arrayRemove:ue,arrayUnion:de,average:be,clearIndexedDbPersistence:ge,collection:i,collectionGroup:ye,connectFirestoreEmulator:_e,count:he,deleteAllPersistentCacheIndexes:me,deleteDoc:d,deleteField:pe,disableNetwork:fe,disablePersistentCacheIndexAutoCreation:Ce,doc:n,documentId:Ae,documentSnapshotFromJSON:Ee,enableIndexedDbPersistence:Pe,enableMultiTabIndexedDbPersistence:ve,enableNetwork:Ie,enablePersistentCacheIndexAutoCreation:Te,endAt:De,endBefore:Se,ensureFirestoreConfigured:Re,executeWrite:Fe,getAggregateFromServer:Qe,getCountFromServer:Le,getDoc:xe,getDocFromCache:Ve,getDocFromServer:we,getDocs:y,getDocsFromCache:Be,getDocsFromServer:qe,getFirestore:Me,getPersistentCacheIndexManager:ke,increment:Ne,initializeFirestore:Oe,limit:We,limitToLast:Ue,loadBundle:Ge,memoryEagerGarbageCollector:He,memoryLocalCache:ze,memoryLruGarbageCollector:Je,namedQuery:Ke,onSnapshot:je,onSnapshotResume:Ze,onSnapshotsInSync:$e,or:Xe,orderBy:Ye,persistentLocalCache:ea,persistentMultipleTabManager:aa,persistentSingleTabManager:ra,query:sa,queryEqual:ta,querySnapshotFromJSON:oa,refEqual:na,runTransaction:ia,serverTimestamp:ca,setDoc:la,setIndexConfiguration:ua,setLogLevel:da,snapshotEqual:ba,startAfter:ga,startAt:ya,sum:_a,terminate:ha,updateDoc:b,vector:ma,waitForPendingWrites:pa,where:fa,writeBatch:Ca},Symbol.toStringTag,{value:"Module"})),Ea=_((s,c)=>({rules:[],deliveryConfig:{enabled:!1,amount:0},isLoading:!1,error:null,fetchRules:async()=>{s({isLoading:!0,error:null});try{const a=i(o,"pricing_rules"),r=(await y(a)).docs.map(t=>({...t.data(),id:t.id}));s({rules:r,isLoading:!1})}catch(a){console.error("Error fetching pricing rules:",a),s({error:a.message,isLoading:!1})}},addRule:async a=>{try{const e=i(o,"pricing_rules");await g(e,a),c().fetchRules()}catch(e){console.error("Error adding rule:",e)}},updateRule:async a=>{try{const{id:e,...r}=a,t=n(o,"pricing_rules",e);await b(t,r),c().fetchRules()}catch(e){console.error("Error updating rule:",e)}},deleteRule:async a=>{try{const e=n(o,"pricing_rules",a);await d(e),s(r=>({rules:r.rules.filter(t=>t.id!==a)}))}catch(e){console.error("Error deleting rule:",e)}},fetchDeliveryConfig:async()=>{try{const a=n(o,"settings","delivery"),e=await l(()=>Promise.resolve().then(()=>u),void 0).then(r=>r.getDoc(a));e.exists()&&s({deliveryConfig:e.data()})}catch(a){console.error("Error fetching delivery config:",a)}},updateDeliveryConfig:async a=>{try{const e=n(o,"settings","delivery");await l(()=>Promise.resolve().then(()=>u),void 0).then(r=>r.setDoc(e,a)),s({deliveryConfig:a})}catch(e){console.error("Error updating delivery config:",e)}}}));export{Ea as u};
