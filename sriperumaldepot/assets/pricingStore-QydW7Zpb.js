import{c as _,e as n,d as o,av as l,h as d,f as b,b as i,z as g,g as y,aw as h,ax as m,ay as p,az as f,aA as C,aB as A,aC as E,aD as P,aE as v,aF as I,aG as T,aH as D,aI as S,aJ as R,aK as F,aL as Q,aM as L,aN as x,aO as V,aP as w,aQ as B,aR as q,aS as M,aT as k,aU as N,aV as O,aW as W,aX as U,aY as G,aZ as z,a_ as H,a$ as J,b0 as K,b1 as j,b2 as Z,b3 as $,b4 as X,b5 as Y,b6 as ee,b7 as ae,b8 as re,b9 as se,ba as te,bb as oe,bc as ne,bd as ie,be as ce,bf as le,bg as ue,bh as de,bi as be,bj as ge,bk as ye,bl as _e,bm as he,bn as me,bo as pe,bp as fe,bq as Ce,br as Ae,bs as Ee,bt as Pe,bu as ve,bv as Ie,bw as Te,bx as De,by as Se,bz as Re,bA as Fe,bB as Qe,bC as Le,bD as xe,bE as Ve,bF as we,bG as Be,bH as qe,bI as Me,bJ as ke,bK as Ne,bL as Oe,bM as We,bN as Ue,bO as Ge,bP as ze,bQ as He,bR as Je,bS as Ke,bT as je,bU as Ze,bV as $e,bW as Xe,o as Ye,bX as ea,bY as aa,bZ as ra,q as sa,b_ as ta,b$ as oa,c0 as na,c1 as ia,a1 as ca,c2 as la,c3 as ua,c4 as da,c5 as ba,c6 as ga,c7 as ya,c8 as _a,c9 as ha,ca as ma,cb as pa,w as fa,cc as Ca}from"./index-BKQIwkgS.js";const u=Object.freeze(Object.defineProperty({__proto__:null,AbstractUserDataWriter:h,AggregateField:m,AggregateQuerySnapshot:p,Bytes:f,CACHE_SIZE_UNLIMITED:C,CollectionReference:A,DocumentReference:E,DocumentSnapshot:P,FieldPath:v,FieldValue:I,Firestore:T,FirestoreError:D,GeoPoint:S,LoadBundleTask:R,PersistentCacheIndexManager:F,Query:Q,QueryCompositeFilterConstraint:L,QueryConstraint:x,QueryDocumentSnapshot:V,QueryEndAtConstraint:w,QueryFieldFilterConstraint:B,QueryLimitConstraint:q,QueryOrderByConstraint:M,QuerySnapshot:k,QueryStartAtConstraint:N,SnapshotMetadata:O,Timestamp:W,Transaction:U,VectorValue:G,WriteBatch:z,_AutoId:H,_ByteString:J,_DatabaseId:K,_DocumentKey:j,_EmptyAppCheckTokenProvider:Z,_EmptyAuthCredentialsProvider:$,_FieldPath:X,_TestingHooks:Y,_cast:ee,_debugAssert:ae,_internalAggregationQueryToProtoRunAggregationQueryRequest:re,_internalQueryToProtoQueryTarget:se,_isBase64Available:te,_logWarn:oe,_validateIsNotUsedTogether:ne,addDoc:g,aggregateFieldEqual:ie,aggregateQuerySnapshotEqual:ce,and:le,arrayRemove:ue,arrayUnion:de,average:be,clearIndexedDbPersistence:ge,collection:i,collectionGroup:ye,connectFirestoreEmulator:_e,count:he,deleteAllPersistentCacheIndexes:me,deleteDoc:d,deleteField:pe,disableNetwork:fe,disablePersistentCacheIndexAutoCreation:Ce,doc:n,documentId:Ae,documentSnapshotFromJSON:Ee,enableIndexedDbPersistence:Pe,enableMultiTabIndexedDbPersistence:ve,enableNetwork:Ie,enablePersistentCacheIndexAutoCreation:Te,endAt:De,endBefore:Se,ensureFirestoreConfigured:Re,executeWrite:Fe,getAggregateFromServer:Qe,getCountFromServer:Le,getDoc:xe,getDocFromCache:Ve,getDocFromServer:we,getDocs:y,getDocsFromCache:Be,getDocsFromServer:qe,getFirestore:Me,getPersistentCacheIndexManager:ke,increment:Ne,initializeFirestore:Oe,limit:We,limitToLast:Ue,loadBundle:Ge,memoryEagerGarbageCollector:ze,memoryLocalCache:He,memoryLruGarbageCollector:Je,namedQuery:Ke,onSnapshot:je,onSnapshotResume:Ze,onSnapshotsInSync:$e,or:Xe,orderBy:Ye,persistentLocalCache:ea,persistentMultipleTabManager:aa,persistentSingleTabManager:ra,query:sa,queryEqual:ta,querySnapshotFromJSON:oa,refEqual:na,runTransaction:ia,serverTimestamp:ca,setDoc:la,setIndexConfiguration:ua,setLogLevel:da,snapshotEqual:ba,startAfter:ga,startAt:ya,sum:_a,terminate:ha,updateDoc:b,vector:ma,waitForPendingWrites:pa,where:fa,writeBatch:Ca},Symbol.toStringTag,{value:"Module"})),Ea=_((s,c)=>({rules:[],deliveryConfig:{enabled:!1,amount:0},isLoading:!1,error:null,fetchRules:async()=>{s({isLoading:!0,error:null});try{const a=i(o,"pricing_rules"),r=(await y(a)).docs.map(t=>({...t.data(),id:t.id}));s({rules:r,isLoading:!1})}catch(a){console.error("Error fetching pricing rules:",a),s({error:a.message,isLoading:!1})}},addRule:async a=>{try{const e=i(o,"pricing_rules");await g(e,a),c().fetchRules()}catch(e){console.error("Error adding rule:",e)}},updateRule:async a=>{try{const{id:e,...r}=a,t=n(o,"pricing_rules",e);await b(t,r),c().fetchRules()}catch(e){console.error("Error updating rule:",e)}},deleteRule:async a=>{try{const e=n(o,"pricing_rules",a);await d(e),s(r=>({rules:r.rules.filter(t=>t.id!==a)}))}catch(e){console.error("Error deleting rule:",e)}},fetchDeliveryConfig:async()=>{try{const a=n(o,"settings","delivery"),e=await l(()=>Promise.resolve().then(()=>u),void 0).then(r=>r.getDoc(a));e.exists()&&s({deliveryConfig:e.data()})}catch(a){console.error("Error fetching delivery config:",a)}},updateDeliveryConfig:async a=>{try{const e=n(o,"settings","delivery");await l(()=>Promise.resolve().then(()=>u),void 0).then(r=>r.setDoc(e,a)),s({deliveryConfig:a})}catch(e){console.error("Error updating delivery config:",e)}}}));export{Ea as u};
